<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Direct Ophthalmoscope Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #4b5563;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body class="bg-gray-900">
    <div id="app" class="h-screen flex">
        <div class="w-80 bg-gray-800 p-4 border-r border-gray-700 overflow-y-auto">
            <div class="flex items-center gap-2 mb-6">
                <svg class="text-blue-400" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
                <h1 class="text-xl font-bold text-white">Direct Ophthalmoscope</h1>
            </div>

            <div class="mb-4 p-3 bg-yellow-900 rounded text-yellow-200 text-xs" id="loadingStatus">
                Loading images from GitHub...
            </div>

            <div class="mb-6 p-4 bg-gray-700 rounded-lg">
                <button id="powerBtn" class="w-full py-3 rounded-lg font-semibold transition flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 text-white">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2v10M18.4 6.6a9 9 0 1 1-12.77.04"/>
                    </svg>
                    <span>POWER OFF</span>
                </button>
            </div>

            <div class="mb-4">
                <label class="text-white text-sm font-semibold mb-2 block">
                    Distance from Eye: <span id="distanceValue">3.0</span> cm
                </label>
                <input type="range" id="distance" min="1" max="12" step="0.5" value="3" class="w-full">
                <div class="text-xs text-gray-400 mt-1" id="distanceHint">Optimal distance</div>
            </div>

            <div class="mb-4">
                <label class="text-white text-sm font-semibold mb-2 block">
                    Diopter Wheel: <span id="diopterValue">0</span>D
                </label>
                <input type="range" id="diopter" min="-20" max="20" step="1" value="0" class="w-full">
                <div class="text-xs text-gray-400 mt-1">Compensate for refractive error & working distance</div>
            </div>

            <div class="mb-4">
                <label class="text-white text-sm font-semibold mb-2 flex items-center gap-2">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"/>
                        <path d="M12 4v1M17.66 6.34l-.71.71M20 12h-1M17.66 17.66l-.71-.71M12 19v1M6.34 17.66l.71-.71M4 12h1M6.34 6.34l.71.71"/>
                    </svg>
                    Light Intensity: <span id="brightnessValue">80</span>%
                </label>
                <input type="range" id="brightness" min="30" max="120" step="5" value="80" class="w-full">
            </div>

            <div class="mb-4">
                <label class="text-white text-sm font-semibold mb-2 block">Aperture Selection</label>
                <div class="grid grid-cols-3 gap-2">
                    <button class="aperture-btn py-2 px-3 rounded text-sm font-medium transition bg-gray-600 text-gray-300 hover:bg-gray-500" data-aperture="small">Small</button>
                    <button class="aperture-btn py-2 px-3 rounded text-sm font-medium transition bg-blue-600 text-white" data-aperture="medium">Medium</button>
                    <button class="aperture-btn py-2 px-3 rounded text-sm font-medium transition bg-gray-600 text-gray-300 hover:bg-gray-500" data-aperture="large">Large</button>
                </div>
            </div>

            <div class="space-y-2 mb-4">
                <button id="quizBtn" class="w-full px-3 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition">
                    Quiz Mode
                </button>
                <button id="effectsBtn" class="w-full px-3 py-2 bg-gray-700 text-white rounded hover:bg-gray-600 transition flex items-center justify-center gap-2">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
                    </svg>
                    <span>Realistic Effects: ON</span>
                </button>
                <button id="infoBtn" class="w-full px-3 py-2 bg-gray-700 text-white rounded hover:bg-gray-600 transition flex items-center justify-center gap-2">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 16v-4M12 8h.01"/>
                    </svg>
                    Hide Info Overlay
                </button>
                <button id="resetBtn" class="w-full px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition flex items-center justify-center gap-2">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                        <path d="M3 3v5h5M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/>
                        <path d="M16 16h5v5"/>
                    </svg>
                    Reset View
                </button>
            </div>

            <div class="p-3 bg-gray-700 rounded-lg">
                <div id="studyPanel">
                    <label class="text-white text-sm font-semibold mb-2 block">Condition:</label>
                    <select id="conditionSelect" class="w-full px-3 py-2 mb-2 bg-gray-600 text-white rounded text-sm">
                    </select>
                    <div class="flex gap-2 mb-2">
                        <button id="prevImg" class="flex-1 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">◀ Prev</button>
                        <button id="nextImg" class="flex-1 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Next ▶</button>
                    </div>
                    <div class="text-xs text-gray-300" id="imageInfo">Image 1/1</div>
                </div>
                
                <div id="quizPanel" style="display:none;">
                    <label class="text-white text-sm font-semibold mb-2 block">Your Diagnosis:</label>
                    <select id="guessSelect" class="w-full px-3 py-2 mb-2 bg-gray-600 text-white rounded text-sm">
                        <option value="">-- Select --</option>
                    </select>
                    <button id="submitGuess" class="w-full py-2 bg-green-600 text-white rounded hover:bg-green-700 mb-2" disabled>Submit</button>
                    <div id="answerPanel" style="display:none;" class="p-2 rounded mb-2 text-sm"></div>
                    <button id="nextQuestion" class="w-full py-2 bg-blue-600 text-white rounded hover:bg-blue-700" style="display:none;">Next →</button>
                    <div class="text-xs text-gray-300 text-center" id="quizScore">Score: 0/0</div>
                </div>
            </div>
        </div>

        <div class="flex-1 flex flex-col items-center justify-center bg-black p-8">
            <canvas id="canvas" width="600" height="600" class="border-4 border-gray-700 rounded-lg cursor-default"></canvas>
            <div class="mt-4 text-gray-400 text-sm text-center max-w-md" id="statusText">
                Turn on the ophthalmoscope to begin examination
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const GITHUB_USER = 'csbrown4';
        const GITHUB_REPO = 'opthosim';
        const GITHUB_BRANCH = 'main';
        const RAW_BASE = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/${GITHUB_BRANCH}`;
        
        // Global state
        let imageLibrary = {};
        let state = {
            isOn: false,
            currentImageIndex: 0,
            currentCondition: 'normal',
            aperture: 'medium',
            diopter: 0,
            brightness: 80,
            distance: 3,
            viewAngle: { x: 0, y: 0 },
            showInfo: true,
            realisticEffects: true,
            quizMode: false,
            userGuess: null,
            showAnswer: false,
            score: { correct: 0, total: 0 },
            isDragging: false,
            lastMouse: { x: 0, y: 0 },
            loadedImages: {},
            imageErrors: {},
            time: 0,
            blinkTimer: 0,
            isLoading: true,
            handTremor: { x: 0, y: 0 },
            pupilSize: 1.0,
            lastPanSpeed: 0,
            heartPhase: 0 // For pulsation
        };

        let allConditions = [];
        let quizImages = [];

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const apertureSettings = {
            small: { size: 80 },
            medium: { size: 120 },
            large: { size: 180 }
        };

        // Audio context for sound effects
        let audioContext = null;
        let ambientHumNode = null;
        let ambientGainNode = null;

        // Initialize audio on first user interaction
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Sound effect functions
        function playPowerClick() {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(200, now + 0.05);
            
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
            
            osc.start(now);
            osc.stop(now + 0.08);
        }

        function playDiopterClick() {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.type = 'square';
            osc.frequency.setValueAtTime(1200, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.02);
            
            gain.gain.setValueAtTime(0.03, now); // Reduced from 0.15 to 0.03
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
            
            osc.start(now);
            osc.stop(now + 0.03);
        }

        function playApertureClick() {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(300, now + 0.04);
            
            gain.gain.setValueAtTime(0.08, now); // Reduced from 0.2 to 0.08
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
            
            osc.start(now);
            osc.stop(now + 0.05);
        }

        function startAmbientHum() {
            if (!audioContext || ambientHumNode) return;
            
            // Create low-frequency hum (like electrical device)
            ambientHumNode = audioContext.createOscillator();
            const filterNode = audioContext.createBiquadFilter();
            ambientGainNode = audioContext.createGain();
            
            ambientHumNode.type = 'sine';
            ambientHumNode.frequency.setValueAtTime(60, audioContext.currentTime); // 60Hz hum
            
            filterNode.type = 'lowpass';
            filterNode.frequency.setValueAtTime(200, audioContext.currentTime);
            
            ambientGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            ambientGainNode.gain.linearRampToValueAtTime(0.02, audioContext.currentTime + 0.5);
            
            ambientHumNode.connect(filterNode);
            filterNode.connect(ambientGainNode);
            ambientGainNode.connect(audioContext.destination);
            
            ambientHumNode.start();
        }

        function stopAmbientHum() {
            if (!ambientHumNode) return;
            
            ambientGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            
            setTimeout(() => {
                if (ambientHumNode) {
                    ambientHumNode.stop();
                    ambientHumNode = null;
                    ambientGainNode = null;
                }
            }, 400);
        }

        // Initialize - load from GitHub API
        async function init() {
            const statusEl = document.getElementById('loadingStatus');
            statusEl.textContent = 'Discovering images from GitHub...';
            
            try {
                // Use GitHub API to get full tree
                const treeResp = await fetch(`https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/git/trees/${GITHUB_BRANCH}?recursive=1`);
                
                if (treeResp.ok) {
                    const treeData = await treeResp.json();
                    const folders = {};
                    
                    console.log('GitHub tree data:', treeData);
                    
                    // Parse tree structure
                    for (const item of treeData.tree) {
                        if (item.type === 'blob' && item.path.includes('/')) {
                            const parts = item.path.split('/');
                            if (parts.length === 2) {
                                const folder = parts[0];
                                const filename = parts[1];
                                
                                if (/\.(jpe?g|png|JPG|JPEG|PNG)$/i.test(filename)) {
                                    if (!folders[folder]) {
                                        folders[folder] = [];
                                    }
                                    folders[folder].push(filename);
                                }
                            }
                        }
                    }
                    
                    console.log('Discovered folders:', folders);
                    
                    // Build image library
                    for (const [folder, files] of Object.entries(folders)) {
                        const displayName = folder.replace(/-/g, ' ')
                            .replace(/\b\w/g, l => l.toUpperCase());
                        
                        imageLibrary[folder] = {
                            name: displayName,
                            images: files.map(f => `${RAW_BASE}/${encodeURIComponent(folder)}/${encodeURIComponent(f)}`)
                        };
                    }
                    
                    const totalImages = Object.values(folders).flat().length;
                    statusEl.textContent = `✓ Loaded ${Object.keys(folders).length} conditions with ${totalImages} images!`;
                    statusEl.className = 'mb-4 p-3 bg-green-900 rounded text-green-200 text-xs';
                    
                    console.log('Image library:', imageLibrary);
                    
                } else {
                    throw new Error(`API returned ${treeResp.status}`);
                }
                
            } catch (err) {
                console.error('Failed to load from GitHub API:', err);
                statusEl.textContent = `⚠ API Error - Check console (F12)`;
                statusEl.className = 'mb-4 p-3 bg-red-900 rounded text-red-200 text-xs';
                
                // Provide a helpful error message
                setTimeout(() => {
                    alert('Failed to load images from GitHub.\n\nPossible issues:\n1. Repository might be private\n2. GitHub API rate limit reached\n3. Network connectivity\n\nCheck browser console (F12) for details.');
                }, 1000);
            }
            
            allConditions = Object.keys(imageLibrary);
            if (allConditions.length > 0) {
                state.currentCondition = allConditions[0];
                updateConditionUI();
                
                setTimeout(() => {
                    const statusEl = document.getElementById('loadingStatus');
                    statusEl.style.display = 'none';
                }, 3000);
            }
            
            state.isLoading = false;
            loadCurrentImage();
        }

        function updateConditionUI() {
            const select = document.getElementById('conditionSelect');
            if (!select) return;
            select.innerHTML = '';
            allConditions.forEach(cond => {
                const opt = document.createElement('option');
                opt.value = cond;
                opt.textContent = imageLibrary[cond].name;
                select.appendChild(opt);
            });
            select.value = state.currentCondition;
            
            // Update image info
            updateImageInfo();
        }

        function updateImageInfo() {
            if (state.quizMode) {
                document.getElementById('imageInfo').textContent = `Question ${state.currentImageIndex + 1}/${quizImages.length}`;
            } else {
                const imgs = imageLibrary[state.currentCondition]?.images || [];
                document.getElementById('imageInfo').textContent = `Image ${state.currentImageIndex + 1}/${imgs.length}`;
            }
        }

        function buildQuizImages() {
            quizImages = [];
            allConditions.forEach(cond => {
                imageLibrary[cond].images.forEach(url => {
                    quizImages.push({ url, condition: cond });
                });
            });
            quizImages.sort(() => Math.random() - 0.5);
            
            // Update quiz dropdown
            const guessSelect = document.getElementById('guessSelect');
            guessSelect.innerHTML = '<option value="">-- Select --</option>';
            allConditions.forEach(cond => {
                const opt = document.createElement('option');
                opt.value = cond;
                opt.textContent = imageLibrary[cond].name;
                guessSelect.appendChild(opt);
            });
        }

        function loadCurrentImage() {
            if (state.quizMode) {
                if (!quizImages || quizImages.length === 0) return;
                const url = quizImages[state.currentImageIndex].url;
                if (state.loadedImages[url] || state.imageErrors[url]) {
                    draw();
                    return;
                }
                loadImage(url);
            } else {
                if (!imageLibrary[state.currentCondition]) return;
                const imgs = imageLibrary[state.currentCondition].images;
                if (!imgs || imgs.length === 0) return;
                
                const url = imgs[state.currentImageIndex];
                if (state.loadedImages[url] || state.imageErrors[url]) {
                    draw();
                    return;
                }
                loadImage(url);
            }
            updateImageInfo();
        }

        function loadImage(url) {
            console.log('Loading image:', url);
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                console.log('✓ Image loaded:', url);
                state.loadedImages[url] = img;
                draw();
            };
            img.onerror = (e) => {
                console.error('✗ Image failed:', url);
                state.imageErrors[url] = true;
                draw();
            };
            img.src = url;
        }

        function calculateFOV() {
            const base = apertureSettings[state.aperture].size;
            const d = state.distance;
            if (d < 1.5) return base * 0.3;
            if (d < 3) return base * (0.5 + (d - 1.5) * 0.4);
            if (d <= 6) return base * (1.1 + (d - 3) * 0.1);
            if (d <= 8) return base * (1.4 - (d - 6) * 0.2);
            return base * 0.8;
        }

        function calculateFocus() {
            const workingDist = 2.5;
            const distDiff = state.distance - workingDist;
            const neededDiopter = -distDiff * 4;
            const focusError = Math.abs(state.diopter - neededDiopter);
            
            if (focusError < 3) return 1.0;
            if (focusError < 8) return 1.0 - (focusError - 3) / 10;
            return Math.max(0.3, 1.0 - focusError / 20);
        }

        function draw() {
            const w = canvas.width, h = canvas.height;
            const cx = w/2, cy = h/2;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            if (!state.isOn) {
                ctx.fillStyle = '#666';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Ophthalmoscope OFF', cx, cy);
                return;
            }

            if (state.realisticEffects) {
                state.time += 0.016;
                
                // Blinking
                if (Math.random() < 0.004) state.blinkTimer = 0.15;
                if (state.blinkTimer > 0) state.blinkTimer -= 0.016;
                
                // Hand tremor - very subtle random shake
                state.handTremor.x += (Math.random() - 0.5) * 0.08; // Much smaller (was 0.3)
                state.handTremor.y += (Math.random() - 0.5) * 0.08;
                state.handTremor.x *= 0.92; // More damping (was 0.85)
                state.handTremor.y *= 0.92;
                
                // Pupil constriction based on brightness
                const targetPupil = 1.0 - (state.brightness - 80) / 200;
                state.pupilSize += (targetPupil - state.pupilSize) * 0.05;
            }

            const fov = calculateFOV() * state.pupilSize;
            const focus = calculateFocus();

            if (state.distance > 8) {
                const pupil = Math.min(fov * 0.8, 100);
                
                // Red reflex with more realistic glow
                const g1 = ctx.createRadialGradient(cx, cy, pupil * 0.5, cx, cy, pupil * 1.2);
                g1.addColorStop(0, 'rgba(255, 120, 70, 0.95)');
                g1.addColorStop(0.6, 'rgba(240, 80, 40, 0.8)');
                g1.addColorStop(0.85, 'rgba(180, 40, 20, 0.5)');
                g1.addColorStop(1, 'rgba(0, 0, 0, 1)');
                ctx.fillStyle = g1;
                ctx.beginPath();
                ctx.arc(cx, cy, pupil * 1.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Add subtle outer glow
                const g2 = ctx.createRadialGradient(cx, cy, pupil * 1.2, cx, cy, pupil * 1.5);
                g2.addColorStop(0, 'rgba(255, 60, 30, 0.2)');
                g2.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = g2;
                ctx.beginPath();
                ctx.arc(cx, cy, pupil * 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                return;
            }

            const imgs = state.quizMode ? 
                (quizImages && quizImages[state.currentImageIndex] ? [quizImages[state.currentImageIndex].url] : []) :
                (imageLibrary[state.currentCondition]?.images || []);
            if (!imgs || imgs.length === 0) return;
            
            const url = state.quizMode ? imgs[0] : imgs[state.currentImageIndex];
            const img = state.loadedImages[url];
            
            if (!img) {
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(cx, cy, fov, 0, Math.PI * 2);
                ctx.fill();
                
                if (state.imageErrors[url]) {
                    ctx.fillStyle = '#f88';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Image failed to load', cx, cy - 10);
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px monospace';
                    const shortUrl = url.split('/').slice(-2).join('/');
                    ctx.fillText(shortUrl, cx, cy + 10);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Loading...', cx, cy);
                }
                return;
            }

            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, fov, 0, Math.PI * 2);
            ctx.clip();

            const blink = (state.realisticEffects && state.blinkTimer > 0) ? Math.min(state.blinkTimer * 5, 0.85) : 0;
            const bright = (state.brightness / 80) * (1 - blink);
            const blur = focus < 0.9 ? Math.floor((1 - focus) * 8) : 0;
            
            // Add motion blur if panning quickly
            const motionBlur = state.realisticEffects ? Math.min(state.lastPanSpeed / 20, 2) : 0;
            const totalBlur = blur + motionBlur;
            
            ctx.filter = totalBlur > 0 ? `brightness(${bright}) blur(${totalBlur}px)` : `brightness(${bright})`;

            const scale = 0.6;
            const iw = img.width * scale, ih = img.height * scale;
            
            // Apply very subtle hand tremor
            const tremorX = state.realisticEffects ? state.handTremor.x : 0;
            const tremorY = state.realisticEffects ? state.handTremor.y : 0;
            
            const ox = cx - iw/2 - state.viewAngle.x + tremorX;
            const oy = cy - ih/2 - state.viewAngle.y + tremorY;
            
            ctx.drawImage(img, ox, oy, iw, ih);
            ctx.filter = 'none';
            
            // Fundus color shift - warmer at periphery, cooler at center
            if (state.realisticEffects) {
                // Calculate distance from center of view
                const panDist = Math.sqrt(state.viewAngle.x * state.viewAngle.x + state.viewAngle.y * state.viewAngle.y);
                const maxPanDist = 500; // Maximum realistic pan distance
                const peripheralness = Math.min(panDist / maxPanDist, 1.0);
                
                // Create radial gradient for color temperature shift
                // Center: slightly cooler (bluer), Periphery: warmer (more orange/red)
                const colorGrad = ctx.createRadialGradient(cx, cy, fov * 0.3, cx, cy, fov * 0.9);
                
                // Subtle effect: center gets slight blue tint, periphery gets orange/red tint
                const centerTint = `rgba(200, 220, 255, ${0.03 * (1 - peripheralness)})`;
                const midTint = `rgba(255, 240, 220, ${0.02})`;
                const edgeTint = `rgba(255, 200, 160, ${0.05 + peripheralness * 0.08})`;
                
                colorGrad.addColorStop(0, centerTint);
                colorGrad.addColorStop(0.5, midTint);
                colorGrad.addColorStop(1, edgeTint);
                
                ctx.fillStyle = colorGrad;
                ctx.globalCompositeOperation = 'overlay';
                ctx.fillRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'source-over';
            }
            
            ctx.restore();

            // Enhanced vignetting with red reflex glow at edges when well-focused
            if (focus > 0.8 && state.realisticEffects) {
                // Red reflex glow around edges
                const glowGrad = ctx.createRadialGradient(cx, cy, fov * 0.7, cx, cy, fov);
                glowGrad.addColorStop(0, 'rgba(255, 80, 40, 0)');
                glowGrad.addColorStop(0.85, 'rgba(255, 60, 30, 0.08)');
                glowGrad.addColorStop(1, 'rgba(255, 40, 20, 0.15)');
                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, fov, 0, Math.PI * 2);
                ctx.clip();
                ctx.fillStyle = glowGrad;
                ctx.fillRect(0,0,w,h);
                ctx.restore();
            }
            
            // Standard vignetting
            const vig = ctx.createRadialGradient(cx, cy, fov * 0.6, cx, cy, fov);
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(0.7, 'rgba(0,0,0,0.3)');
            vig.addColorStop(0.9, 'rgba(0,0,0,0.8)');
            vig.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, fov, 0, Math.PI * 2);
            ctx.clip();
            ctx.fillStyle = vig;
            ctx.fillRect(0,0,w,h);
            ctx.restore();
            
            // Corneal reflection - small bright spot that moves opposite to pan
            if (state.realisticEffects && state.distance <= 6) {
                const reflectX = cx - state.viewAngle.x * 0.15 + fov * 0.35;
                const reflectY = cy - state.viewAngle.y * 0.15 - fov * 0.35;
                const reflectSize = fov * 0.08;
                
                const reflectGrad = ctx.createRadialGradient(reflectX, reflectY, 0, reflectX, reflectY, reflectSize);
                reflectGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                reflectGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                reflectGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = reflectGrad;
                ctx.beginPath();
                ctx.arc(reflectX, reflectY, reflectSize, 0, Math.PI * 2);
                ctx.fill();
            }

            if (state.showInfo) {
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(10, 10, 250, 110);
                ctx.fillStyle = '#fff';
                ctx.font = '14px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Focus: ${focus < 0.7 ? 'Poor' : focus < 0.9 ? 'Fair' : 'Sharp'}`, 20, 30);
                ctx.fillText(`Distance: ${state.distance.toFixed(1)} cm`, 20, 50);
                ctx.fillText(`Diopter: ${state.diopter > 0 ? '+' : ''}${state.diopter}D`, 20, 70);
                ctx.fillText(`Pan: X=${state.viewAngle.x.toFixed(0)} Y=${state.viewAngle.y.toFixed(0)}`, 20, 90);
                if (!state.quizMode) {
                    ctx.fillText(`${imageLibrary[state.currentCondition].name}`, 20, 110);
                } else {
                    ctx.fillText(`Quiz: ${state.currentImageIndex + 1}/${quizImages.length}`, 20, 110);
                }
            }

            if (focus < 0.7) {
                ctx.fillStyle = 'rgba(200, 50, 50, 0.9)';
                ctx.fillRect(w/2 - 120, h - 50, 240, 35);
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Adjust diopter wheel for sharp focus', cx, h - 32);
            }
        }

        // Event handlers
        document.getElementById('powerBtn').addEventListener('click', () => {
            initAudio(); // Initialize audio on first interaction
            
            state.isOn = !state.isOn;
            const btn = document.getElementById('powerBtn');
            btn.className = `w-full py-3 rounded-lg font-semibold transition flex items-center justify-center gap-2 ${state.isOn ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'} text-white`;
            btn.querySelector('span').textContent = state.isOn ? 'POWER ON' : 'POWER OFF';
            canvas.style.cursor = state.isOn && state.distance <= 8 ? 'move' : 'default';
            
            playPowerClick();
            
            if (state.isOn) {
                startAmbientHum();
            } else {
                stopAmbientHum();
            }
            
            draw();
        });

        document.getElementById('distance').addEventListener('input', (e) => {
            state.distance = parseFloat(e.target.value);
            document.getElementById('distanceValue').textContent = state.distance.toFixed(1);
            const hint = state.distance > 8 ? 'Too far - red reflex only' : 
                        state.distance < 1.5 ? 'Too close - very limited view' : 
                        state.distance >= 2 && state.distance <= 5 ? 'Optimal distance' : 'Good distance';
            document.getElementById('distanceHint').textContent = hint;
            canvas.style.cursor = state.isOn && state.distance <= 8 ? 'move' : 'default';
            draw();
        });

        document.getElementById('diopter').addEventListener('input', (e) => {
            state.diopter = parseInt(e.target.value);
            document.getElementById('diopterValue').textContent = `${state.diopter > 0 ? '+' : ''}${state.diopter}`;
            
            // Play click sound (debounced)
            if (audioContext && state.isOn) {
                playDiopterClick();
            }
            
            draw();
        });

        document.getElementById('brightness').addEventListener('input', (e) => {
            state.brightness = parseInt(e.target.value);
            document.getElementById('brightnessValue').textContent = state.brightness;
            draw();
        });

        document.querySelectorAll('.aperture-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!state.isOn) return;
                
                state.aperture = btn.dataset.aperture;
                document.querySelectorAll('.aperture-btn').forEach(b => {
                    b.className = 'aperture-btn py-2 px-3 rounded text-sm font-medium transition bg-gray-600 text-gray-300 hover:bg-gray-500';
                });
                btn.className = 'aperture-btn py-2 px-3 rounded text-sm font-medium transition bg-blue-600 text-white';
                
                playApertureClick();
                
                draw();
            });
        });

        document.getElementById('effectsBtn').addEventListener('click', () => {
            state.realisticEffects = !state.realisticEffects;
            document.querySelector('#effectsBtn span').textContent = `Realistic Effects: ${state.realisticEffects ? 'ON' : 'OFF'}`;
            if (!state.realisticEffects) {
                state.time = 0;
                state.blinkTimer = 0;
                draw();
            }
        });

        document.getElementById('infoBtn').addEventListener('click', () => {
            state.showInfo = !state.showInfo;
            const btn = document.getElementById('infoBtn');
            btn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 16v-4M12 8h.01"/>
                </svg>
                ${state.showInfo ? 'Hide' : 'Show'} Info Overlay
            `;
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            state.viewAngle = { x: 0, y: 0 };
            state.diopter = 0;
            state.distance = 3;
            state.brightness = 80;
            state.aperture = 'medium';
            document.getElementById('distance').value = 3;
            document.getElementById('diopter').value = 0;
            document.getElementById('brightness').value = 80;
            document.getElementById('distanceValue').textContent = '3.0';
            document.getElementById('diopterValue').textContent = '0';
            document.getElementById('brightnessValue').textContent = '80';
            document.getElementById('distanceHint').textContent = 'Optimal distance';
            document.querySelectorAll('.aperture-btn').forEach(b => {
                b.className = b.dataset.aperture === 'medium' ? 
                    'aperture-btn py-2 px-3 rounded text-sm font-medium transition bg-blue-600 text-white' :
                    'aperture-btn py-2 px-3 rounded text-sm font-medium transition bg-gray-600 text-gray-300 hover:bg-gray-500';
            });
            draw();
        });

        // Quiz Mode Toggle
        document.getElementById('quizBtn').addEventListener('click', () => {
            state.quizMode = !state.quizMode;
            const quizBtn = document.getElementById('quizBtn');
            const studyPanel = document.getElementById('studyPanel');
            const quizPanel = document.getElementById('quizPanel');
            
            if (state.quizMode) {
                buildQuizImages();
                state.currentImageIndex = 0;
                state.score = { correct: 0, total: 0 };
                state.userGuess = null;
                state.showAnswer = false;
                
                quizBtn.textContent = 'Exit Quiz';
                quizBtn.className = 'w-full px-3 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition';
                studyPanel.style.display = 'none';
                quizPanel.style.display = 'block';
                
                document.getElementById('guessSelect').value = '';
                document.getElementById('submitGuess').disabled = true;
                document.getElementById('answerPanel').style.display = 'none';
                document.getElementById('nextQuestion').style.display = 'none';
                document.getElementById('quizScore').textContent = `Score: 0/0`;
            } else {
                quizBtn.textContent = 'Quiz Mode';
                quizBtn.className = 'w-full px-3 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition';
                studyPanel.style.display = 'block';
                quizPanel.style.display = 'none';
                state.currentImageIndex = 0;
            }
            
            loadCurrentImage();
        });

        // Condition Select
        document.getElementById('conditionSelect').addEventListener('change', (e) => {
            state.currentCondition = e.target.value;
            state.currentImageIndex = 0;
            state.viewAngle = { x: 0, y: 0 };
            loadCurrentImage();
        });

        // Image Navigation
        document.getElementById('prevImg').addEventListener('click', () => {
            if (state.quizMode) return;
            const imgs = imageLibrary[state.currentCondition]?.images || [];
            if (imgs.length === 0) return;
            state.currentImageIndex = (state.currentImageIndex - 1 + imgs.length) % imgs.length;
            state.viewAngle = { x: 0, y: 0 };
            loadCurrentImage();
        });

        document.getElementById('nextImg').addEventListener('click', () => {
            if (state.quizMode) return;
            const imgs = imageLibrary[state.currentCondition]?.images || [];
            if (imgs.length === 0) return;
            state.currentImageIndex = (state.currentImageIndex + 1) % imgs.length;
            state.viewAngle = { x: 0, y: 0 };
            loadCurrentImage();
        });

        // Quiz Interactions
        document.getElementById('guessSelect').addEventListener('change', (e) => {
            state.userGuess = e.target.value;
            document.getElementById('submitGuess').disabled = !state.userGuess;
        });

        document.getElementById('submitGuess').addEventListener('click', () => {
            if (!state.userGuess) return;
            
            const correctAnswer = quizImages[state.currentImageIndex].condition;
            const isCorrect = state.userGuess === correctAnswer;
            
            state.score.total++;
            if (isCorrect) state.score.correct++;
            
            const answerPanel = document.getElementById('answerPanel');
            answerPanel.className = `p-2 rounded mb-2 text-sm ${isCorrect ? 'bg-green-600' : 'bg-red-600'}`;
            answerPanel.innerHTML = isCorrect ? 
                `<strong>✓ Correct!</strong><br>Diagnosis: ${imageLibrary[correctAnswer].name}` :
                `<strong>✗ Incorrect</strong><br>Your answer: ${imageLibrary[state.userGuess].name}<br>Correct: ${imageLibrary[correctAnswer].name}`;
            answerPanel.style.display = 'block';
            
            document.getElementById('guessSelect').disabled = true;
            document.getElementById('submitGuess').style.display = 'none';
            document.getElementById('nextQuestion').style.display = 'block';
            document.getElementById('quizScore').textContent = `Score: ${state.score.correct}/${state.score.total}`;
        });

        document.getElementById('nextQuestion').addEventListener('click', () => {
            state.currentImageIndex++;
            
            if (state.currentImageIndex >= quizImages.length) {
                const finalScore = ((state.score.correct / state.score.total) * 100).toFixed(1);
                alert(`Quiz Complete!\n\nFinal Score: ${state.score.correct}/${state.score.total} (${finalScore}%)`);
                
                // Reset quiz
                state.quizMode = false;
                document.getElementById('quizBtn').click();
                return;
            }
            
            state.userGuess = null;
            document.getElementById('guessSelect').value = '';
            document.getElementById('guessSelect').disabled = false;
            document.getElementById('submitGuess').disabled = true;
            document.getElementById('submitGuess').style.display = 'block';
            document.getElementById('answerPanel').style.display = 'none';
            document.getElementById('nextQuestion').style.display = 'none';
            state.viewAngle = { x: 0, y: 0 };
            
            loadCurrentImage();
        });

        // Canvas interactions
        canvas.addEventListener('mousedown', (e) => {
            if (!state.isOn || state.distance > 8) return;
            state.isDragging = true;
            const rect = canvas.getBoundingClientRect();
            state.lastMouse = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!state.isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
            const dx = cx - state.lastMouse.x, dy = cy - state.lastMouse.y;
            
            // Track panning speed for motion blur
            state.lastPanSpeed = Math.sqrt(dx * dx + dy * dy);
            
            const newX = state.viewAngle.x + dx * 1.5;
            const newY = state.viewAngle.y + dy * 1.5;
            
            // Elliptical constraint - wider horizontal (nasal/temporal), narrower vertical
            const maxX = 575; // 50 pixels more than before (was 525)
            const maxY = 475; // 50 pixels less vertically
            const normalizedDist = (newX * newX) / (maxX * maxX) + (newY * newY) / (maxY * maxY);
            
            // Only update if within bounds - don't snap to edge
            if (normalizedDist <= 1) {
                state.viewAngle.x = newX;
                state.viewAngle.y = newY;
            }
            // If outside bounds, just don't update position (stay at current position)
            
            state.lastMouse = { x: cx, y: cy };
            draw();
        });

        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            state.lastPanSpeed *= 0.5; // Decay speed
        });
        canvas.addEventListener('mouseleave', () => {
            state.isDragging = false;
            state.lastPanSpeed *= 0.5; // Decay speed
        });

        function animate() {
            if (state.isOn && state.realisticEffects) draw();
            requestAnimationFrame(animate);
        }

        // Start
        init();
        draw();
        animate();
    </script>
</body>
</html>
